import pytest
from unittest.mock import patch

from sinner.models.PerfCounter import PerfCounter, TimingSegment


# test case was generated by AI
class TestPerfCounter:
    @pytest.fixture
    def counter(self):
        """Basic counter fixture"""
        return PerfCounter(name="test_counter")

    @pytest.fixture
    def ns_counter(self):
        """Counter with nanosecond mode enabled"""
        return PerfCounter(name="ns_counter", ns_mode=True)

    @pytest.fixture
    def disabled_counter(self):
        """Counter with stats collection disabled"""
        return PerfCounter(name="disabled_counter", collect_stats=False)

    def test_initialization(self):
        """Test proper initialization of PerfCounter"""
        counter = PerfCounter(name="test", ns_mode=True, collect_stats=False)

        assert counter.name == "test"
        assert counter.ns_mode is True
        assert counter.collect_stats is False
        assert counter.execution_time == 0
        assert counter.segments == {}
        assert counter.subsegments == {}
        assert counter.segment_order == []

    @patch('time.perf_counter')
    def test_context_manager_execution_time(self, mock_perf_counter):
        """Test that execution time is measured correctly"""
        # Setup mock to return increasing values
        mock_perf_counter.side_effect = [10.0, 15.0]  # 5 seconds difference

        counter = PerfCounter()
        with counter:
            pass  # Just enter and exit the context

        assert counter.execution_time == 5.0
        assert counter.start_time == 10.0
        assert counter.end_time == 15.0

    @patch('time.perf_counter_ns')
    def test_ns_mode(self, mock_perf_counter_ns):
        """Test nanosecond mode measurement"""
        # Setup mock to return increasing values in nanoseconds
        mock_perf_counter_ns.side_effect = [10_000_000_000, 15_000_000_000]  # 5 seconds in ns

        counter = PerfCounter(ns_mode=True)
        with counter:
            pass

        assert counter.execution_time == 5_000_000_000  # 5 seconds in nanoseconds

    @patch('time.perf_counter')
    def test_segment_timing(self, mock_perf_counter):
        """Test segment timing measurement"""
        # Mock time values for counter and segment
        mock_perf_counter.side_effect = [
            10.0,  # counter start
            20.0,  # segment start
            25.0,  # segment end
            30.0  # counter end
        ]

        counter = PerfCounter()
        with counter:
            with counter.segment("segment1"):
                pass  # Just measure time

        assert "segment1" in counter.segments
        assert counter.segments["segment1"] == 5.0  # 25 - 20
        assert counter.execution_time == 20.0  # 30 - 10

    @patch('time.perf_counter')
    def test_multiple_segments_order(self, mock_perf_counter):
        """Test multiple segments are recorded in correct order"""
        # Setup time values that ensure predictable segment times
        mock_perf_counter.side_effect = [
            10.0,  # counter start
            11.0,  # segment1 start
            13.0,  # segment1 end
            14.0,  # segment2 start
            18.0,  # segment2 end
            20.0  # counter end
        ]

        counter = PerfCounter()
        with counter:
            with counter.segment("segment1"):
                pass
            with counter.segment("segment2"):
                pass

        assert counter.segment_order == ["segment1", "segment2"]
        assert counter.segments["segment1"] == 2.0  # 13 - 11
        assert counter.segments["segment2"] == 4.0  # 18 - 14

    def test_record_segment_manually(self):
        """Test manually recording a segment"""
        counter = PerfCounter()
        counter.record_segment("manual_segment", 5.5)

        assert "manual_segment" in counter.segments
        assert counter.segments["manual_segment"] == 5.5
        assert "manual_segment" in counter.segment_order

    def test_record_subsegment(self):
        """Test recording a subsegment"""
        counter = PerfCounter()
        counter.record_segment("parent_segment", 10.0)
        counter.record_subsegment("parent_segment", "child_subsegment", 4.0)

        assert "parent_segment" in counter.subsegments
        assert "child_subsegment" in counter.subsegments["parent_segment"]
        assert counter.subsegments["parent_segment"]["child_subsegment"] == 4.0

    def test_percentage_calculation(self):
        """Test percentage calculation for segments"""
        counter = PerfCounter()
        counter.execution_time = 100.0
        counter.record_segment("segment1", 25.0)
        counter.record_segment("segment2", 50.0)

        assert counter.percentage("segment1") == 25.0
        assert counter.percentage("segment2") == 50.0
        assert counter.percentage("nonexistent") == 0.0

    def test_subsegment_percentage(self):
        """Test percentage calculation for subsegments"""
        counter = PerfCounter()
        counter.record_segment("segment", 50.0)
        counter.record_subsegment("segment", "subsegment1", 10.0)
        counter.record_subsegment("segment", "subsegment2", 15.0)

        assert counter.subsegment_percentage("segment", "subsegment1") == 20.0  # 10/50 * 100
        assert counter.subsegment_percentage("segment", "subsegment2") == 30.0  # 15/50 * 100

    def test_str_representation(self):
        """Test string representation output format"""
        counter = PerfCounter(name="test_counter")
        counter.execution_time = 10.0
        counter.record_segment("segment1", 4.0)
        counter.record_segment("segment2", 3.0)
        counter.record_subsegment("segment1", "subsegment", 2.0)

        # Get the string representation
        result = str(counter)
        expected_lines = [
            "test_counter: 10.000000s",
            "  segment1: 4.000000s (40.00%)",
            "    subsegment: 2.000000s (50.00% of segment1)",
            "  segment2: 3.000000s (30.00%)"
        ]

        # Check each line is present
        for line in expected_lines:
            assert line in result

    def test_ns_mode_str_representation(self, ns_counter):
        """Test string representation with nanosecond mode"""
        ns_counter.execution_time = 10_000_000_000  # 10 seconds in ns
        ns_counter.record_segment("segment", 5_000_000_000)  # 5 seconds in ns

        result = str(ns_counter)
        assert "ns_counter: 10000000000.000000ns" in result
        assert "segment: 5000000000.000000ns (50.00%)" in result

    def test_disabled_counter(self, disabled_counter):
        """Test counter with stats collection disabled"""
        with disabled_counter:
            with disabled_counter.segment("segment"):
                pass

        # No segments should be recorded
        assert not disabled_counter.segments
        assert not disabled_counter.segment_order

    def test_str_with_zero_execution_time(self):
        """Test string representation when execution_time is zero but segments exist"""
        counter = PerfCounter()
        # Manually set execution_time to 0 but add segments
        counter.execution_time = 0
        counter.record_segment("segment1", 5.0)
        counter.record_segment("segment2", 7.0)

        result = str(counter)
        # Total time should be calculated from segments
        assert "total: 12.000000s" in result  # 5 + 7

    @patch('time.perf_counter')
    def test_timing_segment_class(self, mock_perf_counter):
        """Test the TimingSegment class"""
        mock_perf_counter.side_effect = [100.0, 105.0]

        counter = PerfCounter()
        segment = TimingSegment(counter, "test_segment")

        with segment:
            pass

        assert "test_segment" in counter.segments
        assert counter.segments["test_segment"] == 5.0

    def test_disabled_timing_segment(self):
        """Test TimingSegment with enabled=False"""
        counter = PerfCounter()
        segment = TimingSegment(counter, "test_segment", enabled=False)

        with segment:
            pass

        # Segment should not be recorded when enabled=False
        assert "test_segment" not in counter.segments

    def test_percentage_with_custom_total(self):
        """Test percentage calculation with custom total time"""
        counter = PerfCounter()
        counter.record_segment("segment", 30.0)

        # Use different total times for calculation
        assert counter.percentage("segment", total_time=60.0) == 50.0
        assert counter.percentage("segment", total_time=150.0) == 20.0

    def test_boundary_zero_division(self):
        """Test boundary case with zero division prevention"""
        counter = PerfCounter()
        # Test with zero execution time
        counter.execution_time = 0
        assert counter.percentage("any_segment") == 0

        # Test with zero segment time
        counter.execution_time = 100.0
        assert counter.subsegment_percentage("nonexistent", "subsegment") == 0

    @patch('time.perf_counter')
    def test_nested_segments(self, mock_perf_counter):
        """Test nested segments recording"""
        mock_perf_counter.side_effect = [
            10.0,  # counter start
            11.0,  # outer start
            12.0,  # inner start
            14.0,  # inner end
            16.0,  # outer end
            20.0  # counter end
        ]

        counter = PerfCounter()
        with counter:
            with counter.segment("outer"):
                with counter.segment("inner"):
                    pass

        assert counter.segments["outer"] == 5.0  # 16 - 11
        assert counter.segments["inner"] == 2.0  # 14 - 12

    def test_add_to_segment_order_idempotence(self):
        """Test that _add_to_segment_order doesn't duplicate entries"""
        counter = PerfCounter()

        # Add the same segment multiple times
        counter._add_to_segment_order("segment")
        counter._add_to_segment_order("segment")
        counter._add_to_segment_order("segment")

        # Should only appear once
        assert counter.segment_order.count("segment") == 1
